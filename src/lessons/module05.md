# Optimization

Welcome to the Optimization week. You've already learned about Instruction Set Architectures (ISAs) and the basics of processor architecture, which are essential for the next step: writing efficient code. This knowledge isn't just theoretical; it's critical for understanding how processors execute instructions and how this impacts your programming. In this module, we'll explore how to use this understanding to write code that aligns with how CPUs work, optimizing for speed and efficiency.

Optimization is about aligning code with the intricacies of hardware. Different processors have unique ways of handling tasks like branching, pipelining, and memory management. We'll use our understanding of ISAs and CPU architecture to improve algorithms, manage resources, and reduce bottlenecks. 

## Topics Covered

- Modern processor architecture and its role in optimizing higher-level code.
- Capabilities of compilers and how they optimize
  - Loop unrolling
  - Reducing procedure calls
  - Eliminating memory references
  - Branch prediction
- Profiling and use of profilers
  - Use of `gprof` and Linux `perf`

## Learning Outcomes

After this week, you will be able to:

- Identify performance bottlenecks in a program.
- Utilize performance analysis tools to measure and improve program efficiency.
- Apply optimization techniques like loop unrolling, software pipelining, and loop interchange.
- Understand the impact of memory access patterns on program performance.


<!-- 
## References:
- https://www.codeproject.com/Articles/6154/Writing-Efficient-C-and-C-Code-Optimization
- https://www.agner.org/optimize/
- https://www.youtube.com/@Computerphile/playlists
- https://github.com/cjl3080434008/2014/blob/master/read_book/Writing%20efficient%20programs%201982.pdf 
- https://ocw.mit.edu/courses/6-004-computation-structures-spring-2017/
- https://ocw.mit.edu/courses/6-172-performance-engineering-of-software-systems-fall-2018/pages/syllabus/
- https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/
- -->